= Tema 5
Creado por Rodrigo Francisco <rhodfra@gmail.com>
Version 1.0, 10.11.2020
:description: Tema 05 BDA
:keywords: procesos
:sectnums: 
// Configuracion de la tabla de contenidos
:toc: 
:toc-placement!:
:toclevels: 4                                          
:toc-title: Contenido

// Ruta base de las imagenes
:imagesdir: ./README.assets/ 

// Resaltar sintaxis
:source-highlighter: pygments

// Iconos para entorno local
ifndef::env-github[:icons: font]

// Iconos para entorno github
ifdef::env-github[]
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

Administración de las estructuras de Memoria

toc::[]

* Los procesos de BD
** Server Processes
** Procesos de background
* Demonios (Daemons) /Application Porcesses
** Un ejemplo es el listener

=== Dedicated Server process

Es un proceso dedicado a un único usuario

La información del proceso se almacena en la UGA (área dentro del PGA)

=== Shared Server process

Todos los usuarios que intente conectarse la instancia van a ser
atendidos por _dispatcher_

Si hay una petición la envía a un fila para que sean atendidas por un
server process (mejor conocido como *shared server process*)

[NOTE]
====
Recordar ejemplo del mesero
====

Los *share server process* se reutilizan para atender varios usuarios

Beneficio: Número de server process son mucho menores.

.El dispatcher soporta múltiples conexiones simultáneas
* A cada conexión se le asocia un pedazo de memoria (*virtual circuit*)

.¿Cuando emplear un shared server process?
* Cuando no tengamos los recursos para atender la demanda
* Considerar que 
** La actividad del procesador va aumentar
** Si tenemos arriba de 500 conexiones concurrentes se recomienda esta técnica.

//-

* _Para bases de datos OLAP se recomienda el modo **dedicado**_
** Operaciones startup y shutdown son en modo dedicado
* _Para bases de datos OLTp se recomienda el modo **compartido**_

Los datos referentes a los procesos en el método *share server process* ya no
se pueden almacenar el el sga, se guardarán en: _shared pool_, _large pool_

Los modos modos pueden convivir: Algunos usuarios se pueden conectar en modo
dedicado y otro me modo compartido.

=== Configuración de los distintos modos

==== Configuración en modo compartido

* `shared_servers` debe ser > 0
* `dispatchers` debe ser > 0

Algunos ejemplos

[source,sql]
----
alter system set dispatcher='(PROTOCOL=tcp)'

alter system set dispatcher='(dispatchers=2)(protocol=tcp)'

alter system set shared_servers = 20;
----

Par usar modo compartido, también es necesario informar al listener

[source,sql]
----
alter system register;
----

Si del lado del sistema operativo tiramos 

`lsnrctl services`

image::lsn.png[]

* D001 y D000 representan los dispatcher activos


== Procesos de background

.Característiscas
* Se encarga de hacerque la instancia funcione correctamente.
* Permiten que múltiples usuarios se conecten a la instancia.
* Monitorean si algún proceso necesita más memoria.
* Ayudan al maximiar el rendimiento

.Hay dos tipos
* Procesos de background *obligatorios*
* Procesos de background *opcionales*
** Generalmente se crean cuando se le agregan más funcionalidades a la BD.

.Los procesos obligatorios son:
* Process Monitor (PMON)
* Process Manager (PMAN)
* System Monitor (SMON)
* Listener Registration (LREG)
* Database Writer (DBWn)
* Log Writer (LGWR)
* Checkpoint (CKPT)
* Manageability Monitor (MMON)
* Manageability Monitor Lite (MMNL)
* Recoverer (RECO)

.Dentro de los procesos de background opcionales más comunes se encuentran:
* Archiver Processes (ARCn)
* Job Queue Processes (CJQ0 y Jnnn)
** Se revisan más en BDD
** Se pueden configurar tareas
* Flashback Data Archive (FBDA)
* Space Management Coordinator (SMCO)
* dispatcher process (Dnnn)

=== PMON. Process Monitor

Se encarga de hacer limpieza. Es decir, acciones de necesarias por si falla
la comunicación entre usuario y servidor.

.Tiene 2 ayudantes
* CLMN (Cleanup Main Process)
* CLnn (Cleanup Helper Processes)

.Tareas
* Reciclas las sessiones húerfanas
* Liberar recursos de un usuario fallado o terminado
* Libera bloqueos
* Detección de termaniaciones anormales de procesos y las 
delegaal CLMN


.La limpieza se puede hacer de

* Procesos terminados.
* Sesiones terminadas.
* Transacciones.
* Conexiones de red.
* Sesiones inactivas.
* Transacciones desconectadas.
* Conexiones de red desconectadas que han excedido su tiempo inactivo

==== Ejercicio

====
. Conectarse con cualquier usuario
+
[source,sql]
----
sqlplus rodrigo0402
----

. Crear una tabla e insertar un registro.
+
[source,sql]
----
create table tes(id number);

insert into test values(1);
----

. En otra terminal
+
[source,sql]
----
select sid, serial#, 
inst_id,machine,status from
gv$session where username='RODRIGO0402'
----

. Podemos matar una sesión
+
[source,sql]
----
alter system kill session '75,41072,@1'
----

. Vemos lo que va a limpiar PMON
+
[source,sql]
----
select type,state,dead_time, cleanup_attempts from v$dead_cleanup;
----

====

=== MAN: Process Manager

Supervisa, genera y detiene los siguientes tipos de procesos:
* Dispatcher y shared server
* Job queue processes
* Procesos de background reiniciables

=== SMON: System Monitor

* Recuperar los datos de transacciones incompletas(uncommited)
que fueron omitidas durante la recuperación de la instancia
* Limpia segmentos temporal que no se utilicen
** Es un área en disco donde se guardan datos de manera 
temporal
* Juntar extensiones libres contiguas dentro del table space

Las extensiones son conjuntos de bloques

image::extensiones.png[]

Fragmentaciónde extensiones

image::extensiones2.png[]

SMON hace la "defragmentación"

image::extensiones3.png[]


=== LREG: Listener Registration

* Obtiene información sobre la instancia de la base de datos y
de posibles dispatcher processes
configurados y los registra o notifica al listener.
** [underline]#Checa si ha cambiado el tipo de conexión# (modo
compartido o modo dedicado.
* Le proporciona al listener la siguiente información
** Los nombres de los servicios
** El nom de la instancia y su carga actual y máxima
* De manera periódica va a buscar un listener si al iniciar la instancia no sé encontró alguno.
* Un listener puede administrar varias instancias y varias
bases de datos.

Le podemos notificar al listener de manera manual que se 
debe conectar con nosotros

[source,sh]
----
alter system register;
# Le indicamos a LREG que actualice los servicios del listener
----

=== DBWn: Database Writer

* Lee buffers sucios y los sincroniza con _data files_
* La operación se considera costosa.
* Proceso perezoso (trata de despertar lo más que se pueda)

.Va a desperta cuando
* Ya no hay buffers limpios o hay muy poquitos
* Se escriben los buffers que no son utilizados con alta 
frecuencia.
* Cuando ocurre un *checkpoint*

Normalmente solo hay un proceso de DBWn

Se recomienda que haya un BDWn por cada procesador.

==== Checkpoint

* Un checkpoint es una señal que le indica a DBW escribir *todos* los buffers sucios que existan en el DB buffer cache.

.Hay de 2 tipos
* Total
** Cuando se hace un cierre ordenado se produce un check point
** Se puede hacer manualmente

* Parcial: Toma solo pedazos de buffer
** Se debe poner una marca para ver que tanto sincronice +

image::chkp-parcial.png[]


















